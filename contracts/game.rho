contract @"CarBrawl"(@{
  "host": host,     // string
  "cost": cost,     // int
}) = {
  new debug(`rho:io:stdout`) in {
    // 购买入场券
    contract @"BuyTicket"(@deployer, @player, return) = {
      new result in {
        @"Transfer"!(deployer, player, host, cost, *result) |
        for (@(success, msg) <- result) {
          if (success) {
            return!((true, player ++ " buy a ticket."))
          } else {
            debug!(msg) |
            return!((false, msg))
          }
        }
      }
    }
    | // 创建游戏
    contract @"CreateGame"(@gameId) = {
      new activeCh, rewardCh, archiveCh, playersCh, rewardPool in {
        debug!("Game " ++ gameId ++ " is created")
        |
        playersCh!({}) |  // {"playerA": 123, "playerB", 234, ...}
        rewardPool!(0) |
        activeCh!(true) |
        archiveCh!([]) |  // [["playerA", 123], ["playerB", 234], ...]
        rewardCh!({})     // {"playerA": 2000, "playerB": 1500, ...}
        | // 启动游戏
        contract @[gameId, "joinGame"](@player, return) = {
          for (@isActive <- activeCh) {
            activeCh!(isActive) |
            if (not isActive) {
              return!((false, "The game " ++ gameId ++ " has already ended."))
            } else {
              for (@prev <- playersCh) {
                if (prev.contains(player)) {
                  playersCh!(prev) |
                  return!((false, "The player " ++ player ++ " has already joined the game " ++ gameId ++ "."))
                } else {
                  for (@prev <- rewardPool) {
                      rewardPool!(prev + cost)
                  } |
                  playersCh!(prev.set(player, 0)) |
                  return!((true, "The player " ++ player ++ " joins the game " ++ gameId ++ "."))
                }
              }
            }
          }
        }
        | // 结算积分
        contract @[gameId, "winPoints"](@pointsMap, return) = {
          for (@isActive <- activeCh) {
            activeCh!(isActive) |
            if (isActive) {
              return!((true, "Changet the points of players in game " ++ gameId ++ ".")) |
              new map in {
                map!(pointsMap) |
                for (@{player: points, ...rest} <= map) {
                  map!(rest) |
                  for (@prev <- playersCh) {
                    if (prev.contains(player)) {
                      playersCh!(prev.set(player, prev.get(player) + points))
                    } else {
                      playersCh!(prev)
                    }
                  }
                }
              }
            } else {
              return!((false, "The game " ++ gameId ++ " has ended"))
            }
          }
        }
        | // 结束对战
        contract @[gameId, "end"](return) = {
          for (_ <- activeCh) {
            return!((true, "The game " ++ gameId ++ " is ended.")) |
            activeCh!(false)
          } |
          new gameResult in {
            for (@players <- playersCh) {
              debug!(players) |
              gameResult!(players) |
              playersCh!({}) |
              for (@{k: v, ...r} <= gameResult) {
                gameResult!(r) |
                for (@prev <- archiveCh) {
                  archiveCh!(prev ++ [[k, v]])
                }
              }
            }
          }
        }
        | // 奖励分配
        contract @[gameId, "reward"](@deployer, return) = {
          for (@isActive <- activeCh; @rwdState <- rewardCh) {
            activeCh!(isActive) |
            rewardCh!(rwdState) |
            if (isActive) {
              return!((false, "The game " ++ gameId ++ " is not ended yet."))
            } else if (rwdState.size() > 0) {
              return!((false, "Can only reward once in the game " ++ gameId ++ "."))
            } else {
              return!((true, "Rewarding in progress.")) |
              for (@l <- archiveCh) {
                // debug!(l) |
                new result, compare in {
                  @"mergeSort"!(l, *compare, *result) |
                  for (@sorted <- result; @R <- rewardPool) {
                    // debug!(sorted) |
                    rewardPool!(0) |
                    archiveCh!(sorted) |
                    new it in {
                      it!(0) |
                      for (@i <= it) {
                        if (i < sorted.length()) {
                          it!(i + 1) |
                          match (sorted.nth(i), sorted.length()) {
                            ([player, _], n) => {
                              new res, computeReward in {
                                computeReward!(R, n - i, n, *res) |
                                for (@reward <- res) {
                                  new _res in {
                                    @"Transfer"!(deployer, host, player, reward, *_res) |
                                    for (@(success, msg) <- _res) {
                                      // No failure is allowed here
                                      if (not success) {
                                        @"Transfer"!(deployer, host, player, reward, *_res)
                                      } else {
                                        // debug!("Reward ${player} ${rwd}" %% { "player": player, "rwd": reward})
                                        for (@prev <- rewardCh) {
                                          rewardCh!(prev.set(player, reward))
                                        }
                                      }
                                    }
                                  }
                                } |
                                contract computeReward(@R, @rk, @n, return) = {
                                  // debug!("total: ${R}, rank: ${rk}, number: ${n}" %% { "R": R, "rk": rk, "n": n}) |
                                  return!(R * (20 + 6 * (n - rk)) / (20 * n + 3 * n * n - 3 * n))
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } |
                  contract compare(@a, @b, return) = {
                    return!(a.nth(1) < b.nth(1))
                  }
                }
              }
            }
          }
        }
        | // 查看奖金分配结果
        contract @[gameId, "checkReward"](return) = {
          for (@final <- rewardCh) {
            rewardCh!(final) |
            if (final.size() > 0) {
              return!((true, "Reward successful.", final))
            } else {
              return!((false, "Not reward yet or failed."))
            }
          }
        }
      }
    }
  }
}